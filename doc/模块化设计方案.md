# 模块化设计方案

本文介绍该项目的模块化设计原则及实现。

## 模块化要解决的问题

模块化解决的是轮子的复用问题。对于基础的，没有其他模块依赖的轮子，例如房间建筑缓存、寻路这种只依赖游戏的模块，可以很简单的复制粘贴就用在自己的项目里。

但是对于一些高等级模块，例如 lab、terminal、战争这种依赖于其他实现的模块，会很难直接复用到其他项目里。其根本原因在于，**在模块内部内联依赖了其他的模块**，例如 lab 模块依赖于房间物流、terminal 依赖于房间资源共享模块、战争依赖于房间孵化和 lab 的 boost 能力。

这里可以套用 JoeArmstrong 的那句话：

> 你想要个香蕉，但拿到的却是拿着香蕉的猩猩，乃至最后你拥有了整片丛林。

你想套用一个 lab 模块，但是你需要同时把房间物流模块也一块装进来，层层嵌套之后，你发现几乎把原来项目一半的代码都搞了过来。随着模块的层级越高，你需要引入的依赖模块就越多。并且你还要避免新引入的猩猩和原来自己写的猩猩打架。

太痛苦了。

## 解决问题的方法：避免内联依赖

什么是内联依赖？例如下面的代码，我在 terminal 模块中需要用到全局的资源共享模块，于是我写下了这样的引用代码：

```javascript
import { getGlobalResourceShare } from 'src/module/resourceShare'
```

呐，这就是内联依赖，**一个模块直接引用了另一个模块**。正是因为这句代码，我们的模块 **直接** 依赖了其他模块，导致了无法只单独复用这一个模块，而接下来的内容就是介绍如何消除掉这些内联依赖代码。

你可能会觉得这不可能啊，不用这些语句引入其他模块，难道你想把所有代码都写在一个文件里？当然不是，**依赖关系不能被彻底删除，但是可以被转移**。

首先看一下我们原本的设计：每个模块相互独立并调用其他模块的接口完成自己的功能，因为彼此之间牵一发而动全身的依赖关系，导致了我们无法单独复用某个模块：

[![ItGa3F.png](https://z3.ax1x.com/2021/11/09/ItGa3F.png)](https://imgtu.com/i/ItGa3F)

但是如果我们通过某种方式“隔离”了其他的接口，让本模块调用的“外部模块操作”是这个隔离层的，然后通过链接这些隔离层，就可以保证模块 **内部** 的纯洁性：

[![ItGU9U.png](https://z3.ax1x.com/2021/11/09/ItGU9U.png)](https://imgtu.com/i/ItGU9U)

这时候我们可以发现，所有“脏乱差”的依赖关系从模块之间沉淀到了一起，为了方便称呼，我们就可以他称之为“胶水层”或正式一点的“组合层”（因为这一层里所有的代码都是为了让模块彼此之间相互合作）。

[![ItGdc4.png](https://z3.ax1x.com/2021/11/09/ItGdc4.png)](https://imgtu.com/i/ItGdc4)

至此，我们就把整个应用分为干净的“模块层”和干脏活的“胶水层”。可以看到，原来那些依赖关系依旧存在，但是从 **模块与模块之间** 转移到了 **模块之外**。

*其实这里的设计就是面向对象中的 DIP 原则，也是 DDD 模型中领域层解决代码腐烂问题的方式。这里不再展开讨论。*

## 如何落实到代码

其实上面的设计给你俩小时你也想得出来。关键就是如何将其落实到代码上面。我们下面的篇幅将介绍如何背靠这种思想写代码：

首先回顾一下上面的图，我们可以意识到，解决这个问题的根本就是 **把模块隔离起来，除了那面“接口墙”上提供的接口，完全不要访问其他外部的东西。**

也就是说，现在的问题就变成怎么隔离代码了。这里我们可以借用纯函数的思想，每个模块都是一个纯函数，函数的参数是其依赖，而函数的返回值是模块实例。即下面的表达式：

[![IUK6yR.png](https://z3.ax1x.com/2021/11/10/IUK6yR.png)](https://imgtu.com/i/IUK6yR)

非常简单对吧，这传达出了一个信息：在你给我传递完所有需要的依赖前，你别想用这个模块，换句话来说：**只要你把函数的参数传递正确，那么这个模块 100% 是可以完整、正常运行的**。这正是我们所期望的。

例如本项目的战争模块（`src/modulesGlobal/war`），他的构建是这样的：

```typescript
// 链接依赖并构建战争模块
const warModule = createWarController({
    getMemory: () => Memory.warMemory,
    // 管理房间 spawn
    remandSpawn: room => room.spawner.remandSpawn(),
    lendSpawn: room => room.spawner.lendSpawn(),
    // 获取物流单位数量
    getRoomManager: room => room.transport.getUnit(),
    // boost 任务管理
    addBoostTask: (room, config) => room.myLab.addBoostTask(config),
    getBoostState: (room, taskId) => room.myLab.getBoostState(taskId),
    boostCreep: (room, creep, taskId) => room.myLab.boostCreep(creep, taskId),
    finishBoost: (room, taskId) => room.myLab.finishBoost(taskId)
    // ...
})
```

**这些内容，就是上文里提到的胶水层代码**，可以看到，这里所有的逻辑都是把其他模块的功能链接进来，并不存在实际的业务代码，并且通过这些代码，非常直观的就可以看到战争模块依赖于那些其他模块。当有其他模块的功能发生变化时，我们只需要跟随胶水层之间的引用关系进行修改即可。**完全不需要侵入模块内部进行修改**。

### 避免隐式依赖

最隐晦、最难以被发现的依赖永远是隐式依赖，特别是没有使用 ts 的时候，有些代码你不读它根本发现不到它还用到了其他模块。而隐式依赖的代表就是全局依赖。

**不要使用全局变量！**

**不要定义全局变量！**

**不要修改全局变量！**

每一个为了少写一行引入而放在全局的变量，就是在为屎山的堆积添一份力。

想要使用一个依赖，就把他堂堂正正的引入进来，告诉别人和明天的自己，这个函数是别的模块的，我就是要在这里使用它。所有想节省代码量的取巧操作最后都会变为面向脑容量编程。