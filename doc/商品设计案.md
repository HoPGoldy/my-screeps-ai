# 商品设计案（设计阶段）

以下的”生产线“是指参与进行商品合成的所有房间，”节点“是指单个生产商品的房间。

## 核心规则

- 每个房间生产的商品都不会主动发送至其他房间，只有在收到请求时才会发送。
- 房间在生产时发现需要低等级商品时，会通过资源共享协议发出请求。
- 房间均偏向独立，可以自己合成的就不会去请求其他房间。

## 整体设计

- 全局存有一个核心模块，该模块只是用于给玩家提供一个统一的访问入口，便于设置一些全局信息和进行查看。并不会对节点房间进行指挥调度。
- 普通房间通过用户指定房间命令成为节点房间，节点房间采用队列模式，自行完成可以合成的产品，如果无法合成则通过房间共享协议进行请求。

## CLI 设计

### Global

设置生产线目标

值为 Metal, Silicon, Biomass, Mist 的一种，默认会根据自己房间所处象限进行选择（自动初始化执行于玩家第一次调用 `Room.fsetlevel()`）。

```ts
comp.set(compType)
```

显示当前生产线状态，显示内容包括：

- 当前五级产物数量
- 所有加入生产线的节点
- 每个节点的当前任务信息、状态、任务队列长度

```
comp.show()
```

### Room

设置当前房间等级，值为 1-5，代表了对应的工厂等级。该命令执行操作如下：

- 尝试移除之前的资源共享注册
- 初始化房间等级
- 进行新的资源共享协议注册

```
Room.fsetlevel(number)
``` 

查看当前房间生产状态：显示如下信息：

- 工作状态
- 任务队列的目标和数量

```
Room.fshow()
```

## 房间生产流程

factory 采用任务队列模式，该队列只有 factory 能接触到，当队列为空时，factory 会推入 **自己等级内** 能生产的最高级产品（*下文称为“顶级产物”* ）的任务，数量为 1。

**- 任务分解**

任务很容易会出现因为底物不足而无法生产的问题。该问题一旦出现，factory 会进行如下工作：

- 遍历该任务的所有底物
- 如果底物可以合成，则向队列中推入该底物的合成任务
- 如果底物无法合成，则向 roomShare 提交共享请求
- 将该任务移至队列末尾

通过这种方法，无法合成的高级任务会被逐步细化成更底层的低级任务。

**- 任务处理**

factory 采用和 lab 类似的分阶段工作逻辑，共分为四个阶段：`prepare`、`getResource`、`working`、`putResource`。

- `prepare`：factory 会在这个阶段检查任务队列，并对任务进行新增或分解操作，一旦发现可以生成的任务，则进入下个阶段。
- `getResource`：对比自己存储中的资源和当前任务需要的资源，并移入不足的资源，一旦底物准备就绪，则进入下个阶段。
- `working`：factory 会一直尝试 `produce`，直到返回 `ERR_NOT_ENOUGH_RESOURCES` 后进入下个阶段。
- `putResource`：移除自己存储中所有的资源（一般情况下都只会有产物），净空后返回第一个阶段。

**- 低等级房间供货不足所带来的堵塞**

从上面的”任务分解“逻辑可以得知，在无法获得共享资源的情况下，随着任务完成的数量增加，需要共享的任务被检查次数会越来越多，从而使得共享请求频率逐步增加，以此来提高请求被响应的几率。

如果低等级房间因为原料任务无法生产所需要的产品。那么依赖他的高等级房间就会因为任务队列中的任务无法完成 > 无法增加新的生产任务从而陷入停滞状态（*这里是优化点* ）。由于任务队列的存在，一旦需要的底物共享了过来，生产会立刻从断点继续。

**- 多个顶级产物的任务选择**

如果该房间的等级允许制造多个顶级产物的话，那么就会根据以下规则进行选择：

- 房间存在的资源共享任务恰好是顶级产物中的一个的话就直接进行生成。
- 自己内存中存有一个索引，根据索引来遍历所有顶级产物。

## factory 和 terminal 之间的关系

terminal 是和 factory 交互最频繁的建筑，factory 会从 terminal 中获取大多数原料，并且在生成完成后也会将产物移至 terminal。和 lab 一样，factory 并不会关心原料是如何获取的，这部分交由 terminal 负责，玩家可以由此设置自己的生产线，例如低等级的商品直接从市场进货而非自己生产。

## factory 和 centerTransfeTask 之间的关系

factory 完全依赖于中央物流系统，鉴于 factory 产品的重要性，需要对现有的中央物流系统进行检查，提高其稳定性及转移数量准确性。

## factory 和资源共享协议的关系

商品的多房间共享完全依赖于资源共享协议，所有的产品共享都通过标准的房间共享任务完成流转。但由于当前的物流任务并非队列模式，其任务响应顺序和 factory 共享任务增加对原有体系的影响还有待检查。

## factory 和 power 之间的关系

- factory 在生产后会检查自己身上 `PWR_OPERATE_FACTORY` 的剩余时间，当低于 40 tick 时会推送 power 任务至队列。
- powerCreep 在发现该任务后会去校验 `Room.memory.factory.level` 字段，这个字段必须和自己的 power 等级一致之后才会执行。如果不同会邮件通知玩家，若玩家认同该操作则应手动执行 `Room.fsetlevel`。

## 持久化

**Memory**

```ts
{
    // 当前生产线的种类
    type: DepositConstant,
    // 生成线中的所有参与房间
    // 以下键为等级，值为房间名称数组
    node: {
        1: string[]
        2: string[]
        3: string[]
        4: string[]
        5: string[]
    }
}
```

**Room.memory**

```ts
{
    // 当前房间的等级，由用户指定
    level: number
    // 当前正在制作的顶级产品
    topTarget: CommodityConstant
    // 当前工厂所处的阶段
    state: FACTORY_STATE
    // 工厂生产队列
    taskList: {
        // 任务目标
        target: CommodityConstant,
        // 该任务要生成的数量
        amount: number
    }[]
}
```

**setting**

```ts
// 标志每个等级所能生产的顶级商品
factoryTopTarget: {
    // 每条生产线都会对应一套顶级产品
    [Metal, Silicon, Biomass, Mist]: {
        1: CommodityConstant[]
        2: CommodityConstant[]
        3: CommodityConstant[]
        4: CommodityConstant[]
        5: CommodityConstant[]
    }
}
```