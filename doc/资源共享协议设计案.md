# 资源共享协议设计案（已废弃）

---- **该设计案已废除** ----

资源共享协议用于在多房间之间**长期**共享彼此的资源，用于合成更高级的化合物和货物。

# 基本框架

资源共享协议分为控制器和执行器。

控制器位于全局，以类似与终端的执行方式遍历玩家手动安排的共享任务列表，一旦发现某个任务未完成，则给执行器安排资源转移任务，如果执行器已经有一个在执行的任务的话，则继续检查下个任务。

**注意**：资源共享任务必须保证拥有 source 房间的视野，不然将无法正常发布任务，并且当 target 房间没有视野时，则会跳过检查直接通知需要执行任务。

执行器是每个房间内的终端，控制器分配的资源共享任务优先级高于自己房间的资源监听任务。一旦发现自己收到了资源共享任务，则会立即收集路费并准备发送。

# 共享任务列表

共享任务列表位于全局 Memory，由控制器负责监听，类型为数组。

共享任务由玩家手动设置，设置后不会自动取消。其格式如下：

```js
// 位于 Memory 跟路径下
roomShare: {
    // 任务列表
    tasks: [
        // 单个任务
        {   
            // 资源的提供房间
            source: 'W1N1',
            // 资源的接受房间
            target: 'W1N2',
            // 共享的资源类型
            resourceType: RESOURCE_ENERGY,
            // 期望数量
            amount: 10000
        }
    ]
}
```

其中的期望数量负责任务的触发，一旦控制器发现 target 房间指定资源的数量小于 amount，则会向 source 指派共享任务。但是

# 控制台设计

**增**：向共享任务队列添加一个新的任务

```js
share.add(source, target, resourceType, amount)
```

**查**：显示当前所有的任务及其 **id**

```js
share.get()
```

**删**：使用任务的 id 删除该任务

```js
share.remove(taskId)
```

**改**：使用任务 id 重新设置该任务

```js
share.set(taskId, source, target, resourceType, amount)
```

# 执行器设计

房间内存存在如下字段：

```js
shareTask: {
    // 要发送到的房间
    target: 'W1N1',
    // 要发送的资源数量
    resourceType: RESOURCE_ENERGY,
    // 要发送的资源量
    amount: 50000
}
```

房间终端在工作时会优先检查该字段，如果有指定的资源和足够的数量的话，就会开始要路费并进行资源转移，如果资源不足的话就会继续剩下的正常工作（继续工作可能会生成所需的资源）。

当房间终端完成资源共享后，会移除该字段。

控制器在发现需要执行某个资源共享任务时，也会去检查指定房间的该字段。一旦发现存在该字段（该房间尚在执行其他共享任务），则暂时不添加。