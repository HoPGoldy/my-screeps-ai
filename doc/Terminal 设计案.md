# 终端设计案（已实装）

# 核心需求

终端的作用是与外界（市场或其他友方房间）交互来维持房间内指定资源的数量。核心需求如下：

- 房间内某样资源缺了就要从外面获取（买或者从其他房间要）
- 房间内某样资源太多了就要提供出去（卖或者给其他房间）

# 资源监听规则

根据上面两个核心需求我们进行观察后可以归纳出如下属性：

物流方向: *资源从本房间流出还是流入*

- **获取**: 本房间缺少某种资源，从外界获取资源供本房间使用
- **提供**: 本房间某种资源富裕，提供给外界使用

物流渠道: *资源通过什么方式进行流入流出*

- **挂单**: cr 充足时可以在市场上挂单来买入或卖出资源
- **拍单**: 通过拍下市场上的订单来买入或卖出资源
- **共享**: 通过资源共享协议在自有的房间里转移资源

可以看到，物流方向和物流渠道是多对多的关系。每一种组合都可以衍生出一种规则。并且由于房间间物流的复杂性，并不存在一套规则可以应付所有房间的需求。所以本设计案的解决方案是 **开放一套接口，外部（玩家或者其他模块的代码）可以自由的对规则进行制定**，而这组规则会被保存在房间内存中，并指导 terminal 完成对外物流交互工作。

# 设计 - 资源监听任务（资源监听规则）

上文中提到的单条规则应包含如下属性：

```js
{
    // 资源类型，该规则对那个资源生效
    type: RESOURCE_POWER,
    // 资源的期望值
    amount: 1000,
    // 物流方向
    mod: 'get' // 'put'
    // 物流渠道
    channel: 'release' // 'take' 'share'
}
```

在其中引入了“期望值”的概念，这个值代表了该规则的触发条件。例如上面的规则的意思就是：若房间内的 `RESOURCE_POWER` 数量低于 1000 就通过挂单来获取资源。

需要注意的是，期望值要结合物流方向来看，当 `mod === 'put'` 时，就代表着若该资源的数量超过期望值就通过指定渠道对外提供资源。该设计正是通过这两种监听方式来解决开头提到的两种核心需求。

# 接口设计

- 添加资源监听规则（提供上述参数，将其加入房间规则列表）
- 移除资源监听规则
- 查看监听列表

# 优化

- 监听规则不需要每 tick 都过一遍，可以保存一个指针，每隔一段时间检查一次指针指向的规则，通过之后就指向下一个规则。

- 存储压缩：本项目会将单条规则序按指定顺序列化成字符串，在需要查阅该条规则时再进行解压缩，由此来减少小对象的解析消耗。

# 三种物流渠道的交易实现

## 1、拍单

- 当发现资源数量不符合期望值时，会去市场查找合适的订单。
- 没有找到就指针后移检查下个规则（等下次循环到了再试一次）。
- 找到了就缓存该订单的 id，并向中央物流系统推送能量获取任务（取路费）。
- 下个 tick 发现有缓存的订单 id 就检查路费是否到位，到位了就进行交易，然后将指针后移。

## 2、挂单

- 发现资源数量不符合期望时，就会尝试发布订单。
- 首先检查是否已经发布过相同需求的订单了（同房间、同类型、同资源）
- 已有订单，如果价格发生变化就更新价格，然后更新订单数量
- 没有订单，直接新建
- 指针后移（挂单之后就不需要自己操作了，如果订单没有异常资源会自己发过来）

## 3、资源共享

- 发现资源不符合预期时就访问资源共享协议来获取资源或者把自己注册为资源提供房间

# 关于价格

无论是挂单还是拍单价格检查都非常重要，挂单需要参考市场价格进行定价，而拍单更不能拍到过高或者过低的坑单。所以可以在获取到价格后通过访问历史均价来检查价格是否位于正确区间以内。当然，也可以提供额外的 `priceLimit` 属性来进行硬性限制。防止长时间不管后历史均价不符合自己的预期。

资源共享是无条件的，不需要价格检查。

# 示例

通过组合简单规则，我们可以创造出非常个性化的物流策略，下面就是一些示例：

**deposit 原料共享**

```js
[
    { type: RESOURCE_METAL, amount: 10000, mod: 'get', channel: 'release' },
    { type: RESOURCE_METAL, amount: 500, mod: 'get', channel: 'share' },
    { type: RESOURCE_METAL, amount: 500, mod: 'put', channel: 'share' }
]
```

上面的规则含义为：通过市场挂单来把自己房间内的 `metal` 维持在 10000 以上，并且如果数量大于 500 就对其他房间提供 `metal`，同时如果市场上有没有买 `metal` 的导致其数量低于 500 了，那么就通过资源共享尝试从其他房间获取 `metal`。

**power 控制**

```js
// 有能力挖 power 的房间
[
    { type: RESOURCE_METAL, amount: 5000, mod: 'put', channel: 'share' }
]
// 没有能力挖 power 的房间
[
    { type: RESOURCE_POWER, amount: 100, mod: 'get', channel: 'take' },
    { type: RESOURCE_POWER, amount: 5000, mod: 'get', channel: 'share' }
]
```

上面的规则含义为：当有能力挖 `power` 的房间堆积了 5000 以上的 `power` 后就对其他房间提供。而没有能力挖 `power` 的房间将尝试从资源共享获取。如果从共享获取不到导致 `power` 吃到不足 100 了，就开始从市场拍单进货。

# Q & A

- 为什么要先实现一个返回错误码的接口层，然后在在其基础上封装一个返回字符串的用户操作层？

    *用户操作层是面向玩家的，需要返回文字解释来方便操作，而接口层是面向其他模块的，他们可以通过错误码来完成接下来的逻辑处理。*