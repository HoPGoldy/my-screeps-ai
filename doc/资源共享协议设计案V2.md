# 资源共享协议设计案V2（已实装）

# 新需求及老版本的不足

老版资源共享协议需要手动指定每个任务。

而由于 lab 集群采用的是分布式的设计思想，每个房间内都需要维持相同的基本矿物数量。

所以需要一个自动化的资源共享协议来避免为每一个房间配置大量相同且繁琐的共享任务。

# 设计思路

在全局维护一个资源来源表，标注了自己已经拥有的基础矿物（由每个房间内的 Extractor 注册）。

而 terminal 会监听自己存储中的基础资源数量，如果不足的话会将自己的需求委托给资源共享控制器。控制器会访问资源来源表，如果里边有需要的基础矿物的话，控制器会向对应的来源房间发布共享任务，并向发起委托的 terminal 返回是否安排上了。

terminal 则会根据返回值决定下一步操作。

# 维护者

拓展 Extractor，其建成时将会检查一次自己是否在“资源来源表”里注册，没有注册则进行注册。

注：这里会存在一旦失去了房间控制权后没人处理其遗留在”资源来源表“里的失效数据的问题。下面的控制器会解决该问题。

# 资源来源表

```js
{
    // 其键代表资源类型，值为数组，包含了可以提供该资源的房间名
    [RESOURCE_HYDROGEN]: [ 'W1N2', 'W3N4' ],
    [RESOURCE_KEANIUM]: [ 'W5N6', 'W2N6' ],
    // ...
}
```

# 资源共享控制器

控制器的主要作用是提供一套 API 来方便 terminal 、资源来源表、来源房间之间的沟通，不会主动运行，仅被动响应委托者的请求。拓展在 `Room` 原型内，具体设计如下：

向控制器请求资源，接受资源类型和数量，返回有没有安排上

```ts
shareRequest(resourceType, amount): boolean
```

在资源来源表中添加自己, 返回是否添加成功（添加失败的主要原因是已经添加过了）

```ts
shareAddSource(resourceType, roomName): boolean
```

在资源来源表中移除自己

```ts
shareRemoveSource(resourceType, roomName): void
```

私有方法，给本房间发添加资源共享任务，接受目标房间名、资源类型和数量，返回是否添加成功

```ts
shareAdd(targetRoom, resourceType, amount): boolean
```

私有方法，查找来源房间，接受资源类型，返回房间对象，没找到则返回 null

该方法会检查房间的可访问状态，如果目标房间可以提供资源则返回，不可提供资源则继续查找并在资源来源表里移除该房间

```ts
shareGetSource(resourceType): Room | null
```

# 资源共享执行器

执行器的作用是处理安排给本房间的资源共享任务，老版本的代码可以兼容新版设计，不予修改。

# 关于能量共享

拓展 storage 原型，每 10000 tick 会检查一下自己的能量，如果大于指定上限就将自己加入到资源来源表里。

控制器在收到能量共享请求时，会依次检查能量来源房间的 storage，如果能量还是大于指定上限则分配任务，否则直接移除该房间